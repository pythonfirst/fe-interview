## 实现一个Promise/A+规范的Promise

### Promise/A+版本

```js
// Specification https://promisesaplus.com/
function MyPromise(executor) {

  // 2.1 Promise 必须有以下三种状态之一：pending, fulfilled 或者 rejected
  this.state = 'pending';
  // 2.2.6.1 如果promise 处于 fulfilled 状态，所有相对应的 onFulfilled 回调必须按照它们对应的 then 的原始顺序执行
  this.onFulfilledCallback = [];
  // 2.2.6.2 如果 promise 处于rejected 状态，所有相应的 onRejected 回调必须按照特闷对应的 then 的调用顺序执行
  this.onRejectedCallBack = [];

  const self = this;
  function resolve(value) {
    // 2.1.1 当 promise 处于 pending 状态时：
    // 2.1.1.1 可以转换到 fulfilled  或 rejected 状态
    // 2.1.2 当 promise 处于 fulfilled 状态时：
    // 2.1.2.1 不得过渡到任何状态
    // 2.1.2.2 必须有个不能改变的值
    setTimeout(() => {
      if (self.state === 'pending') {
        self.state = 'fulfilled';
        self.data = value;  // TODO: 没看懂data 是做什么用
  
        for (let i=0; i<self.onFulfilledCallback.length; i++) {
          self.onFulfilledCallback[i](value);
        }
      }
    });
  }

  function reject(reason) {
    // 2.1.1 当 promise 处于 pending 状态时：
    // 2.1.1.1 可以转换到 fulfilled  或 rejected 状态
    // 2.1.3 当 promise 处于 rejected 状态时：
    // 2.1.3.1 不得过渡到任何状态
    // 2.1.3.2 必须有一个不能改变的值
    setTimeout(() => {
      if (self.state === 'pending') {
        self.state = 'rejected';
        self.data = reason;
  
        for (let i=0; i<self.onRejectedCallBack.length; i++) {
          self.onRejectedCallBack[i](reason)
        }
      }
    });
  }

  // 立即执行executor
  // 用户传入的函数可能会执行异常，所以这里用try...catch 包裹
  try {
    executor(resolve, reject);
  } catch (reason) {
    reject(reason)
  }
}

// 2.2 then方法
// 一个 promise 必须有一个 then 方法来访问当前值或者最终值或者 rejected值
// 一个 promise 的 then 方法接收两个参数：
// promise.then(onFulfilled, onRejected)
MyPromise.prototype.then = function(onFulfilled, onRejected) {
  const self = this;

  let promise2;
  // 2.2.7 then 必须返回一个promise

  return (promise2 = new MyPromise((resolve, reject) => {
    // 2.2.2 如果 onFulfilled 是一个函数：
    // 2.2.2.1 它必须在 promise 的状态变为 fulfilled 后调用，并将 promise 的值作为它的第一个参数
    // 2.2.2.2 它一定不能在 promise 的状态变为 fulfilled 之前调用。
    // 2.2.2.3 它最多只能被调用一次
    if (self.state === 'fulfilled') {
      // 2.2.2 onFulfilled 或 onRejected 在执行上下文堆栈仅包含平台代码之前不得调用
      // 3.1 这可以通过 "宏任务" 机制 （例如 setTimeout 或 setImmediate）或 "微任务" 机制（例如：MutationObserver 或 process.nextTick) 来实现
      setTimeout(function() {
        // 2.2.1 onFulfilled 和 onRejected 都是可选参数
        //2.2.1.1 如果 onFulfilled 如果不是一个函数，则必须被忽略
        if (typeof onFulfilled === 'function') {
          try {
            // 2.2.2.1 它必须在 promise 的状态变为 fulfilled 后被调用， 并将 promise 的值作为它的第一个参数
            const x = onFulfilled(self.data);
            // 2.2.7.1 如果 onFulfilled 或 onRejected 返回了一个值x，则运行 Promise 处理程序 [[Resolve]](promise2, x)
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch (e) {
            // 2.2.7.3 如果onFulfilled
            reject(e)
          }
        } else {
          // 2.2.7.3 如果onFulfilled 不是一个函数且 promise1 为 fulfilled 状态，且 promise2 必须和promise1 一样的值变为 fulfilled状态
          resolve(self.data)
        }
      })
    }

    // 2.2.3 如果 onRejected 是一个函数
    // 2.2.3.1 它必须在 promise 的状态变为 rejected 后被调用， 并将 promise 的reason 作为它的第一个参数
    // 2.2.3.2 它一定不能在 promise 的状态变为 rejected 之前调用
    // 2.2.3.3 它最多只能被调用一次
    else if (self.state === 'rejected') {
      // 2.2.2 onFulfilled 或 onRejected 在执行上下文堆栈仅包含平台代码之前不得调用
      // 3.1 这可以通过 "宏任务" 机制 （例如 setTimeout 或 setImmediate）或 "微任务" 机制（例如：MutationObserver 或 process.nextTick) 来实现
      setTimeout(function() {
        // 2.2.1 onFulfilled 和 onRejected 都是可选参数
        //2.2.1.1 如果 onFulfilled 如果不是一个函数，则必须被忽略
        if (typeof onRejected === 'function') {
          try {
            // 2.2.3.1. 它必须在 promise 的状态变为 rejected 后被调用，并将 promise 的 reason 作为它的第一个参数。
            // 2.2.5. onFulfilled 和 onRejected 必须作为函数调用。
            const x = onRejected(self.data)
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        }
        // 2.2.7.4 如果 onRejected 不是一个函数且promise1 为 rejected 状态，promise2 必须用和 promise 一样的 reason 来变为 rejected 状态。
        else {
          reject(self.data)
        }
      });
    }

    else if (self.state === 'pending') {
      // 2.2.6 then 可能会被同一个 promise 调用
      // 2.2.6.1 如果 promise 处于 fulfilled 状态，所有相应的 onFulfilled 回调必须按照它们对应的 then 的原始回调顺序来执行
      self.onFulfilledCallback.push(function(promise1Value) {
        if (typeof onFulfilled === 'function') {
          try {
            const x = onFulfilled(self.data);
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        } else {
          resolve(promise1Value)
        }
      })

      // 2.2.6.2 如果 promise 处于 rejected 状态，所有相应的 onRejected 回调必须按照它们对应的 then 的原始顺序来执行。
      self.onRejectedCallBack.push(function(promise1Reason) {
        if (typeof onRejected === 'function') {
          try {
            const x = onRejected(self.data);
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        } else {
          reject(promise1Reason)
        }
      })
    }
  }))
}


// 2.3 Promise 处理程序
// Promise 处理程序是一个将 promise 和 value 作为输入的抽象操作， 我们将其表示为 [[Resolve]](promise, x)
// 补充说明：这里我们将resolve 和 reject 也传进来，因为后续要根据不同的逻辑对 promise 执行 fulFill 或 reject 操作
function promiseResolutionProcedure(promise2, x, resolve, reject) {
  // 2.3.1 如果 promise 和 x 引用的是同一个对象，promise 将以一个 TypeError 作为reason 来进行 reject。
  if (promise2 === x) {
    reject(new TypeError('Chaining cycle detected for promise'))
  }

  // 2.3.2 如果 x 是一个promise, 则根据它的状态：
  if (x instanceof MyPromise) {
    // 2.3.2.1 如果 x 的状态为pending, promise 必须保持 pending 状态直到 x 的状态变为 fulfilled 或 rejected
    if (x.state === 'pending') {
      x.then(function(value) {
        promiseResolutionProcedure(promise2, value, resolve, reject)
      }, reject)
    }

    // 2.3.2.3 如果 x 的状态为 fulfilled，那么 promise 也用同样的值来执行 fulfill操作
    else if (x.state === 'fulfilled') {
      resolve(x.data)
    }

    // 2.3.2.3 如果 x 的状态为 rejected，那么 promise 也用同样的 reason 来执行 reject 操作
    else if (x.state === 'rejected') {
      reject(x.data)
    }

    return;
  }

  // 2.3.3 除此之外， 如果 x 是一个对象或函数
  if (x && (typeof x === 'object' || typeof x === 'function')) {
    // 2.3.3.3 如果 resolvePromise 和 rejectPromise 都被调用，或者多次调用同样的参数， 则第一次调用优先，任何之后调用都被忽略
    let isCalled = false;

    try {
      // 2.3.3.1 声明一个 then 变量来保存 then
      let then = x.then;

      // 2.3.3.3 如果 then 是一个函数，将 x 作为 this 来调用它，第一个参数为 resolvePromise, 第二个参数为 rejectPromise, 其中：
      if (typeof then === 'function') {
        then.call(
          x,
          // 2.3.3.1 假设 resolvePromise 使用一个名为 y 的值来调用， 运行promise 处理程序
          function resolvePromise(y) {
            // 2.3.3.3 如果 resolvePromise 和 rejectPromise 都被调用，或者多次调用同样的参数， 则第一次调用优先，任何之后调用的都忽略
            if (isCalled) return;
            isCalled = true;

            return promiseResolutionProcedure(promise2, y, resolve, reject)
          },
          // 2.3.3.3.2 假设 rejectPromise 使用一个名为 r 的reason 来调用， 则用r 作为reason 对 promise 执行reject 操作。
          function rejectPromise(r) {
            if (isCalled) return;
            isCalled = true;

            return reject(r)
          }
        )
      }
      // 2.3.3.4 如果then 不是一个函数， 使用x 作为值对 promise 执行fulfill 操作
      else {
        resolve(x)
      }

    } catch (e) {
      // 2.3.3.2. 如果检索 x.then 的结果抛出异常 e，使用 e 作为 reason 对 promise 执行 reject 操作。
      // 2.3.3.3.4. 如果调用 then 时抛出一个异常 e，
      // 2.3.3.3.4.1. 如果 resolvePromise 或 rejectPromise 已经被调用过了，则忽略异常。
      if (isCalled) return;
      isCalled = true;
      // 2.3.3.3.4.2. 否则，使用 e 作为 reason 对 promise 执行 reject 操作。
      reject(e);
    }
  } else {
    // 2.3.4 如果 x 不是一个对象或者函数， 使用 作为值对 promise 执行 reject 操作
    resolve(x)
  }
}


const promise1 = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    // resolve('success')
    reject('err')
  }, (1500));
})

promise1.then(value => {
  console.log('promise1 then1 value', value);
  return value
}, reason => {
  console.log('promise1 then1 reason', reason)
  return reason
})
.then(value => {
  console.log('promise1 then2 value', value);
}, reason => {
  console.log('promise1 then2 reason', reason)
})

const promise2 = new Promise((resolve, reject) => {
  setTimeout(() => {
    // resolve('success')
    reject('err')
  }, (1500));
})

promise2.then(value => {
  console.log('promise2 then2 value', value);
}, reason => {
  console.log('promise2 then2 reason', reason)
})
.then(value => {
  console.log('promise2 then2 value', value);
}, reason => {
  console.log('promise2 then2 reason', reason)
})

module.exports = MyPromise
```

### 简略版本

```js
const PENDING = 'pending';
const FULFILLED = 'fulfilled';
const REJECTED = 'rejected';

/**
 * 框架：
 * 1. 变量：state/onFulfilledCallback/onRejectedCallback
 * 2. 方法：resolve/reject
 * 3. 参数：executor
 * 4. 执行代码 try catch
 * @param {*} executor 
 */
function MyPromise(executor) {

  this.state = PENDING;
  this.onFulfilledCallback = [];
  this.onRejectedCallback = [];
  const self = this;

  function resolve(value) {
    setTimeout(function() {
      if (self.state === PENDING) {
        self.state = FULFILLED;
        self.data = value;
        for (let i=0; i< self.onFulfilledCallback.length; i++) {
          self.onFulfilledCallback[i](value);
        }
      }
    });
  }

  function reject(reason) {
    setTimeout(function() {
      if (self.state === PENDING) {
        self.state = REJECTED;
        self.data = reason;
        for (let i=0; i<self.onRejectedCallback.length; i++) {
          self.onRejectedCallback[i](reason)
        }
      }
    });
  }

  try {
    executor(resolve, reject);
  } catch (reason) {
    reject(reason)
  }
}

/**
 * 框架：
 * 1. 三个状态：pending/fulfilled/rejected
 * 2. 返回一个新的 promise
 * @param {*} onFulfilled 
 * @param {*} onRejected 
 */
MyPromise.prototype.then = function (onFulfilled, onRejected) {
  const self = this;
  let promise2 = new MyPromise((resolve, reject) => {
    if (self.state === PENDING) {
      // onFulfilled push
      self.onFulfilledCallback.push(function(promise1Value) {
        if (typeof onFulfilled === 'function') {
          try {
            const x = onFulfilled(self.data);
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        } else {
          resolve(promise1Value)
        }
      })

      // onRejected push
      self.onRejectedCallback.push(function(promise1Reason) {
        if (typeof onRejected === 'function') {
          try {
            const x = onRejected(self.data);
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch(e) {
            reject(e)
          }
        } else {
          reject(promise1Reason)
        }
      })
    }
  
    else if (self.state === FULFILLED) {
      setTimeout(function(){
        if (typeof onFulfilled === 'function') {
          try {
            const x = onFulfilled(self.data);
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        } else {
          resolve(self.data)
        }
      });
    }
  
    else if (self.state === REJECTED) {
      setTimeout(function() {
        if (typeof onRejected === 'function') {
          try {
            const x = onRejected(self.data);
            promiseResolutionProcedure(promise2, x, resolve, reject)
          } catch (e) {
            reject(e)
          }
        } else {
          resolve(self.data)
        }
      });
    }
  })

  return promise2
}

/**
 * 框架
 * 1. 判断返回的 x 与 promise2 是否为同一个引用
 * 2. 判断是否为 promise
 * 3. 判断是否为 object || function
 * @param {*} promise2 then 返回的promise2
 * @param {*} x then 函数 onFulfilled 回调
 * @param {*} resolve promise2 的resolve方法
 * @param {*} reject promise2 的reject方法
 */
function promiseResolutionProcedure(promise2, x, resolve, reject) {
  // 循环引用
  if (x === promise2) {
    return reject(new TypeError('Chain cycle detected'))
  }

  // 根据状态来判断
  if (x instanceof MyPromise) {
    // 通过调用then来实现等待状态变为 fulfilled 或者 rejected
    if (x.state === PENDING) {
      x.then(function(value) {
        promiseResolutionProcedure(promise2, value, resolve, reject)
      }, reject)
    }

    else if (x.state === FULFILLED) {
      resolve(x.data)
    }

    else if (x.state === REJECTED) {
      reject(x.data)
    }
    return
  }

  if (x && (typeof x === "object" || typeof x === "function")) {
    let isCalled = false;

    try {
      let then = x.then;

      if (typeof then === "function") {
        then.call(
          x,
          function resolvePromise(y) {
            if (isCalled) return;
            isCalled = true;
            return promiseResolutionProcedure(promise2, y, resolve, reject);
          },
          function rejectPromise(r) {
            if (isCalled) return;
            isCalled = true;
            return reject(r);
          }
        );
      } else {
        resolve(x);
      }
    } catch (e) {
      if (isCalled) return;
      isCalled = true;
      reject(e);
    }
  } else {
    resolve(x);
  }
}

const promise1 = new MyPromise((resolve, reject) => {
  setTimeout(() => {
    // resolve('success')
    reject('err')
  }, (1500));
})

promise1
.then(value => {
  console.log('promise1 then1 value', value);
  return value
}, reason => {
  console.log('promise1 then1 reason', reason)
  return reason
})
.then(value => {
  console.log('promise1 then2 value', value);
}, reason => {
  console.log('promise1 then2 reason', reason)
})

module.exports = MyPromise
```

### 其它方法

```js
// resolve 方法
MyPromise.resolve = function(val) {
  return new MyPromise((resolve, reject) => {
    resolve(val)
  })
}

// reject 方法
MyPromise.reject = function(reason) {
  return new MyPromise((resolve, reject) => {
    reject(reason)
  })
}

// race 方法
MyPromise.race = function(promises) {
  return new MyPromise((resolve, reject) => {
    for (let i=0; i<promises.length; i++) {
      promises[i].then(resolve, reject)
    }
  })
}

MyPromise.all = function(promises) {
  const res = [];
  let i=0;

  function processData(index, data, resolve) {
    res[index] = data;
    i++;
    if (i === promises.length) {
      resolve(res)
    }
  }

  return new MyPromise((resolve, reject) => {
    for (let i=0; i<promises.length; i++) {
      promises[i].then(data => {
        processData(i, data, resolve)
      }, reject)
    }
  })

}

MyPromise.prototype.catch = function(errCallback) {
  return this.then(null, errCallback)
}

MyPromise.prototype.finally = function(callback) {
  return this.then((value)=>{
    return Promise.resolve(callback()).then(()=>value)
  },(reason)=>{
    return Promise.resolve(callback()).then(()=>{throw reason})
  })  
}
```

### promise 包装ajax



## debounce & throttle

### debounce

```js
/**
 * 1. 返回一个函数
 * 2. 函数内存在settimeout,settimeout延迟支持原函数
 * 3. 支持绑定原this
 * 4. 支持原生events对象
 * 5. 立刻执行，ns后才能触发
 * 6. 返回值
 * 7. 取消
 * @param {*} func 回调函数
 * @param {*} wait 等待时长
 * @param {Boolean} immediate 是否立即执行
 * @returns 
 */
function debounce(func, wait, immediate=false) {
	let timeout, result;

	const debouned = function() {
		let self = this;
		const args = arguments;
	
     // 运行前先取消
		if (timeout) clearTimeout(timeout)
		// 立即执行	
		if (immediate) {
			let callNow = !timeout;
			
			timeout = setTimeout(() => {
				timeout = null;
			}, wait)

			if (callNow) {
				result = func.apply(self, args)
				return result;
			}
		} else {
			// 非立即执行
			timeout = setTimeout(func.bind(self, ...args), wait);
		}

		// 支持取消
		debouned.cancel = function() {
			clearTimeout(timeout);
			timeout = null;
		}

		// 返回函数执行结果
		return result
	}
	return debouned
}
```

### throttle

```js
/**
 * 截流：固定时间段内只执行一次

 * @param {*} func 
 * @param {*} wait 等待时间
 * @param {leading, trailing} options 
 * @returns 
 */
function throttle(func, wait, options={}) {
	let timeout
	let previous = 0;
	let self;
	let args;

	function later() {
		previous = +new Date();
		timeout = null;
		func.apply(self, args);
	}
	const throttled = function() {
		self = this;
		args = arguments;
		const now = +new Date();

		if (!previous && options.leading === false) previous = now;

		// 用于停止触发后，判断trailing的触发事件；
		const remain = wait - ( now - previous);

		if (remain <=0 || remain > wait) {
			if (timeout) {
				clearTimeout(timeout);
				timeout = null;
			}
			previous = now;
			func.apply(self, args)
		} else if (!timeout && options.trailing !== false) {
			timeout = setTimeout(later, remain);
		}
	}

	return throttled
}
```

## apply & bind & call

### apply

```js
/**
 * 思路：使用context调用该函数，最后再删除
 * 考虑参数
 * @param {*} context 
 */
Function.prototype.apply2 = function (context) {
	// 如果第一个参数传入null,则this为window
	context = context || global;
	// 将调用函数的参数取出来
	const arr = Array.from(arguments).slice(1)
	// 将调用的函数this添加为context的方法
	context.fn = this;
	// 在context上调用该方法并返回该函数返回值
	const res = context.fn(...arr);
	// 删除该对象上临时添加的方法
	delete context.fn;

	return res;
}

```

### call(与apply相似)

```js
/**
 * 1. 绑定this为接收的第一个参数
 * 2. 接收其余参数作为绑定函数的参数
 * 3. 函数具有返回值
 * 4. 兼容传入的参数为nul的情况 // node 为global，browser为window
 * @param {*} context 
 */
Function.prototype.call2 = function (context) {
	// 如果第一个参数传入null,则this为window
	context = context || window;
	// 将参数提取为数组
	const args = Array.from(arguments).slice(1) // 如果要求不使用ES6，可以用for循环
	// 将调用的函数this添加为context的方法
	context.fn = this;

	// 在context上调用该方法并返回该函数返回值
	const res = context.fn(...args);
	// 删除该对象上临时添加的方法
	delete context.fn;

	return res;
}
```

### bind

```js
/**
 * 1. 返回一个函数
 * 2. 返回的函数绑定制定this
 * 3. 支持不固定参数
 * 4. 支持使用new创建
 * 4.1 支持继承绑定函数原型的属性。
 * @param {*} context 
 * @returns 
 */
Function.prototype.bind2 = function(context) {

		if (typeof this !== 'function') {
			return new Error('请使用函数调用')
		}
		const self = this;

		const args = Array.prototype.slice.call(arguments).slice(1);

		function fBind() {
			const bindArgs = Array.prototype.slice.call(arguments);
			
     	// 支持具有返回值
			return self.apply(this instanceof fBind ? this : context, args.concat(bindArgs))
		}

		const fNOP = function(){}
		fNOP.prototype  = self.prototype;
		fBind.prototype = new fNOP();

		return fBind;
}
```

## 函数柯里化

[彻底弄懂柯里化](https://juejin.cn/post/6844903665308794888)

```js
function curry(fn, args) {
	let length = fn.length;
	args = args || [];

	return function() {
		newArgs = args.concat(Array.prototype.slice.call(arguments));
		if (newArgs.length < length) {
			return curry.call(this, fn, newArgs);
		} else {
			return fn.apply(this, newArgs);
		}
	}
}

function multiFn(a, b, c) {
	return a * b * c;
}

var multi = curry(multiFn);
console.log(multi(1)(3)(2))
```

## 深拷贝 & 浅拷贝

```js
/**
 * 兼容不同的类型：DOM/Date/RegExp/set/map/array
 * 兼容循环引用
 * 风险：date的复制/DOM的类型判断及复制/regExp的复制
 * @param {*} obj 
 * @param {*} map 
 */
function deepClone(obj, map = new WeakMap()) {
	// 先校验是否为对象，如果不为对象，则返回原来的值

	if (typeof obj !== 'object') return obj;

	if (map.get(obj)) return map.get(obj)

	let copyObj
	const type = getType(obj);

	let map = new WeakMap();
	if (type === 'node') {
		copyObj = obj.cloneNode(true);
	} else if (type === 'date') {
		copyObj = new Date(obj.getTime());
	} else if (type === 'regExp') {
		// 兼容正则
		var flags = [];
		if (obj.global) { flags.push('g')};
		if (obj.multiline) { flags.push('m')};
		if (obj.ignoreCase) { flags.push('i')};

		copyObj = new RegExp(obj.source, flags.join(''))
	} else {
		copyObj = type === 'array' ? [] : {};
		map.set(obj, copyObj);
		if (type === 'array' || type === 'set' || type === 'map') {
			obj.array.forEach((e, k) => {
				copyObj[k] = typeof e === 'object' ? deepClone(e, map) : e;
			});
		} else {
			Object.keys(obj).forEach(k => {
				copyObj[k] = typeof obj[k] === 'object' ? deepClone(obj[k], map) : obj[k];
			})
		}
	}
	
	return copyObj;
}


function getType(obj) {

	if (obj.nodeType && 'cloneNode' in obj) return 'node';

	const _toString = Object.prototype.toString;
	const _type = _toString(obj);
  
	switch (_type) {
		case '[object Date]':
			return 'date'
		case '[object RegExp]':
			return 'regExp'
		case '[object Map]':
			return 'map'
		case '[object Set]':
			return 'sets'

		default:
			return Array.isArray(obj) ? 'array' : 'object'
	}
}
```

## 单例模式

## 观察者模式

## 数组转树



## 解析 URL params



