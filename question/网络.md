

## HTTP协议

### HTTP缓存

#### 强缓存：

不需要额外向服务器发送请求校验，直接使用本地缓存，不走协商阶段。

如何标识使用强缓存：cache-control/Pragma(http1.0)/expires

```js
response header
------
cache-control字段
no-store // 客户端不可以缓存资源，每次都要去服务器验证
no-cache // 可以缓存但不使用强缓存，每次使用前先去服务端验证有效期 ->协商缓存
must-revalidate // 如果不过期可以继续使用，如果过期了，则必须验证后使用
max-age // 缓存有效期，单位秒，起始时间为responseDate+max-age // 如果在有效期则使用缓存，如果过期则走协商缓存。
// 其他值
private // 私有缓存，中间代理不可以缓存
public // 中间代理可以缓存
------
Pragma // Http1.0字段 只有一个no-cache，表示走协商缓存
------
expires // 缓存到期时间的时间戳，优先级最低

```

#### 协商缓存

如果强缓存过期(max-age/expires)或者设置不走强缓存(no-cache)，则进入协商缓存阶段。

如果请求头重携带if-modified-since/if-none-match(etag) ，则向服务器请求查看资源是否新鲜， 如果更新则返回最新的资源（200），如果未更新则缓存还有效，返回304 Not Modified。

#### 相关header：

etag优先级高于last-modified

```js
W/etag  // response header 资源摘要  W表示弱校验
if-none-match // request header 与etag配合使用，优先级高于last-modified/if-modified-since
------
last-modified  // response header
if-modified-since  // request header与last-modified配合使用
------

```

### HTTPs

解决了保密性、完整性、身份认证、不可否认的问题。

#### Https 与Http的区别

1. Https在Http与TCP/ip之间增加了一层SSL/TLS
2. Http是明文传输，Https为加密传输
3. Https可以验证网络安全性

#### SSL/TLS如何进行加密方式

https使用混合加密方式，即通过对称加密协商出一个对称加密的密钥，之后用对称加密。

对称加密、非对称加密、混合加密，对于加密二字很容易理解，对于明文都能看懂，加密就是通过一些步骤把明文变密文，让人看不懂，只有使用密钥解密一下，密文变明文了大家又都能看懂了。
那啥是对称？啥是非对称？啥是混合？
对称强调A钥匙加密只有A钥匙能解码
非对称强调A钥匙加密后只有B钥匙能解密，B钥匙加密后只有A钥匙能解码。这个感觉好神奇，就好像我上锁后谁都能打开，上锁是没用的只能证明锁是我上的。
混合强调非对称和对称的组合使用，非对称用于密钥交换，对称用于数据的安全传输。

保密性：靠混合加密解决，非对称加密实现对称加密秘钥传递，对称加密实现内容加密。
完整性：靠摘要算法解决。
身份认证：靠数字证书解决，数字证书因为CA机构的信任变成一个完整信任链条，从而实现通过数字证书证明了对方真实身份，但注意身份真实也可能是挂羊头卖狗肉，是一个坏人，所以，有了CRL、OCSP，还有终止信任。
不可否认：靠数字签名解决，内容摘要算法得到摘要，私钥加密摘要，对方使用对应公钥解密，得到摘要，再和自己得到的服务器提供的原文摘要对比，一致说明这个内容就是原服务器提供的，由证书说明了服务器的身份。

### HTTP2 &HTTP3

HTTP2通过头部压缩、二进制分帧以及流的多路复用解决了HTTP层面的队头阻塞。

HTTP3通过舍弃TCP(使用udp)来解决TCP丢包重传造成的队头阻塞。

## Websocket

## service worker

## TCP/IP

host => host 协议，根据端口号来区分不同的应用。

### 为什么三次握手四次挥手

建立链接：SYN->ACK(SYN)->ACK

关闭连接： FIN->ACK FIN->ACK

























